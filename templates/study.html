{% extends "base.html" %}

{% block title %}Study - Cloudflare Showcase{% endblock %}

{% block content %}
<style>
#scripture-tabs,
#tab-content {
    display: none;
    width: 100%;
}
</style>

<script>
// Handle connection status
htmx.defineExtension("ws-connection-status", {
    onEvent: function (name, evt) {
        const connectionStatus = document.getElementById("connection-status");
        if (!connectionStatus) return;

        const baseClasses = "inline-block text-sm font-medium rounded-full px-4 py-1 w-fit";

        switch (name) {
            case "htmx:wsConnecting":
                connectionStatus.textContent = "Connecting...";
                connectionStatus.className = `${baseClasses} bg-yellow-100 text-yellow-600`;
                break;
            case "htmx:wsOpen":
                connectionStatus.textContent = "Connected";
                connectionStatus.className = `${baseClasses} bg-green-100 text-green-600`;
                break;
            case "htmx:wsClose":
                connectionStatus.textContent = "Disconnected - Reconnecting...";
                connectionStatus.className = `${baseClasses} bg-red-100 text-red-600`;
                break;
        }
    }
});

// Debug logging extension
htmx.defineExtension('ws-debug', {
    onEvent: function(name, evt) {
        switch(name) {
            case 'htmx:wsBeforeMessage':
                this.logMessage(evt.detail.message, 'RECEIVED');
                break;
            case 'htmx:wsBeforeSend':
                this.logMessage(evt.detail.message, 'SENT');
                break;
            case 'htmx:wsOpen':
                this.logMessage('WebSocket Connected', 'CONNECT');
                break;
            case 'htmx:wsClose':
                this.logMessage('WebSocket Disconnected', 'DISCONNECT');
                break;
            case 'htmx:wsError':
                this.logMessage('WebSocket Error', 'ERROR');
                break;
        }
    },
    logMessage: function(msg, direction) {
        const logDiv = document.getElementById('message-log');
        if (!logDiv) return;

        const MAX_MESSAGES = 100;
        
        while (logDiv.children.length >= MAX_MESSAGES) {
            logDiv.removeChild(logDiv.firstChild);
        }

        const ARROWS = {
            RECEIVED: 'üì•',
            SENT: '‚¨ÜÔ∏è',
            CONNECT: 'üîÑ',
            DISCONNECT: 'üî¥',
            ERROR: '‚ö†Ô∏è'
        };

        const logEntry = document.createElement('div');
        const timestamp = new Date().toLocaleTimeString();
        
        let msgType = '';
        try {
            JSON.parse(msg);
            msgType = '{json} ';
        } catch (e) {
            msgType = '&lt;html&gt; ';
        }

        logEntry.className = `whitespace-pre ${
            direction === 'ERROR' ? 'text-red-400' :
            direction === 'CONNECT' ? 'text-yellow-400' :
            direction === 'DISCONNECT' ? 'text-yellow-400' :
            direction === 'RECEIVED' ? 'text-blue-400' : 
            'text-green-400'
        }`;
        
        const formattedMsg = msg.trim()
            .replace(/\s{2,}/g, ' ')
            .replace(/\n+/g, '\n')
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');

        logEntry.innerHTML = `[${timestamp}] ${ARROWS[direction]} ${msgType} ${formattedMsg}`;
        
        logDiv.appendChild(logEntry);
        logDiv.scrollTop = logDiv.scrollHeight;
    }
});

htmx.defineExtension('form-handler', {
    onEvent: function (name, evt) {
        if (name === 'htmx:wsConfigSend') {
            evt.detail.parameters = {};
            const form = evt.detail.triggeringEvent.target.closest('form');
            const inputs = form.querySelectorAll('input, select, textarea');
            inputs.forEach((input) => {
                const controlType = input.type || input.tagName.toLowerCase();
                let value = controlType === 'checkbox' ? input.checked : input.value;
                evt.detail.parameters['control_name'] = input.name;
                evt.detail.parameters['control_value'] = value;
                evt.detail.parameters['control_type'] = controlType;
            });

            // For local updates, update tabs immediately
            if (evt.detail.parameters.control_name === 'scriptures') {
                updateScriptureTabs(evt.detail.parameters.control_value);
            }

            return {
                value: JSON.stringify(evt.detail.parameters)
            };
        }
    }
});

function updateScriptureTabs(scriptures) {
    const tabsContainer = document.getElementById('scripture-tabs');
    const contentContainer = document.getElementById('scripture-content');
    
    if (!tabsContainer || !contentContainer) return;

    // Clear existing tabs and content
    tabsContainer.innerHTML = '';
    contentContainer.innerHTML = '';

    // Split scriptures by newlines
    const references = scriptures.split('\n').filter(ref => ref.trim());
    
    if (references.length > 0) {
        tabsContainer.style.display = 'flex';
        contentContainer.style.display = 'block';
        
        references.forEach((reference, index) => {
            // Create tab button
            const tab = document.createElement('button');
            tab.className = `px-4 py-2 text-sm font-medium rounded-t-lg break-words ${
                index === 0 
                    ? 'bg-white text-blue-600 border-l border-r border-t border-gray-200' 
                    : 'text-gray-500 hover:text-gray-700 bg-gray-50'
            }`;
            tab.textContent = reference.trim();
            tab.onclick = () => switchTab(index);
            tabsContainer.appendChild(tab);

            // Create content div
            const content = document.createElement('div');
            content.id = `scripture-content-${index}`;
            content.className = `bg-white rounded-lg shadow-sm p-4 break-words whitespace-pre-wrap ${index === 0 ? '' : 'hidden'}`;
            contentContainer.appendChild(content);
        });
    } else {
        tabsContainer.style.display = 'none';
        contentContainer.style.display = 'none';
    }
}

function switchTab(selectedIndex) {
    const tabs = document.getElementById('scripture-tabs').children;
    const contents = document.getElementById('scripture-content').children;

    Array.from(tabs).forEach((tab, index) => {
        if (index === selectedIndex) {
            tab.className = 'px-4 py-2 text-sm font-medium rounded-t-lg break-words bg-white text-blue-600 border-l border-r border-t border-gray-200';
        } else {
            tab.className = 'px-4 py-2 text-sm font-medium rounded-t-lg break-words text-gray-500 hover:text-gray-700 bg-gray-50';
        }
    });

    Array.from(contents).forEach((content, index) => {
        content.className = `bg-white rounded-lg shadow-sm p-4 break-words whitespace-pre-wrap ${index === selectedIndex ? '' : 'hidden'}`;
    });
}

// Update the form-update-handler to handle both local and remote scripture updates
htmx.defineExtension('form-update-handler', {
    transformResponse: function (text, xhr, elt) {
        try {
            let data;
            if (xhr && xhr.responseText) {
                const response = JSON.parse(xhr.responseText);
                data = response.value ? JSON.parse(response.value) : response;
            } else {
                data = JSON.parse(text);
            }

            // Store content updates until tabs are ready
            if (data.id && data.id.startsWith('scripture-content-')) {
                if (!window.pendingContentUpdates) {
                    window.pendingContentUpdates = new Map();
                }
                window.pendingContentUpdates.set(data.id, data.value);
            }

            // Handle control messages first
            if (data.control_type && data.control_name && data.control_value !== undefined) {
                // Update the control value
                const element = document.getElementById(data.control_name) || 
                              document.querySelector(`[name="${data.control_name}"]`);
                if (element) {
                    element.value = data.control_value;
                }
                
                // If it's a scriptures update, update the tabs and apply pending content
                if (data.control_name === 'scriptures') {
                    console.log('Updating tabs from remote change:', data.control_value);
                    updateScriptureTabs(data.control_value);
                    
                    // Apply any pending content updates
                    if (window.pendingContentUpdates) {
                        window.pendingContentUpdates.forEach((value, id) => {
                            const contentDiv = document.getElementById(id);
                            if (contentDiv) {
                                contentDiv.innerHTML = value;
                            }
                        });
                        window.pendingContentUpdates.clear();
                    }
                }
            }
            // Handle other updates
            else if (data.id === 'client-count') {
                const clientCount = document.getElementById('client-count');
                if (clientCount) {
                    clientCount.textContent = data.value;
                }
                const connectionStatus = document.getElementById("connection-status");
                if (connectionStatus && connectionStatus.classList.contains('bg-green-100')) {
                    connectionStatus.textContent = `${data.value} Participants`;
                }
            } else if (data.id && data.id.startsWith('scripture-content-')) {
                // Apply content update if tabs exist, otherwise it's already stored in pendingContentUpdates
                const contentDiv = document.getElementById(data.id);
                if (contentDiv) {
                    contentDiv.innerHTML = data.value;
                }
            }
            return text;
        } catch (e) {
            console.error('Error processing message:', e);
            return text;
        }
    }
});
</script>

<div class="h-screen flex flex-col p-4 overflow-hidden" 
     hx-ext="ws,ws-connection-status,form-handler,form-update-handler,ws-debug"
     ws-connect="/study_do">
    <!-- Header -->
    <div class="bg-white rounded-lg shadow-sm p-4 mb-4 flex-none">
        <div class="flex justify-between items-center">
            <h1 class="text-2xl font-bold text-gray-800">Study Session</h1>
            <aside id="connection-status" 
                   class="inline-block text-sm font-medium rounded-full px-4 py-1 w-fit bg-red-100 text-red-600">
                Disconnected
            </aside>
            <span id="client-count" class="hidden">0</span>
        </div>
    </div>

    <!-- Main Content Area - Scrollable -->
    <div class="flex-1 min-h-0 flex flex-col overflow-hidden">
        <div class="bg-gray-50 p-6 rounded-lg flex-1 flex flex-col overflow-hidden">
            <!-- Fixed Height Input Section -->
            <div class="flex-none">
                <!-- Topic Input -->
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700">Topic</label>
                    <form ws-send="keyup" hx-trigger="keyup delay:300ms" hx-target="this" onsubmit="return false;">
                        <input type="text" 
                               name="study-topic" 
                               class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                    </form>
                </div>

                <!-- Scriptures Input -->
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700">Scriptures</label>
                    <form ws-send="keyup" hx-trigger="keyup delay:300ms" hx-target="this" onsubmit="return false;">
                        <textarea name="scriptures"
                                  rows="4"
                                  class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
                                  placeholder="Enter scripture references"></textarea>
                    </form>
                </div>

                <!-- Scripture Result -->
                <div class="scripture-container">
                    <!-- Tab Headers -->
                    <div id="scripture-tabs" class="flex flex-wrap gap-2 border-b border-gray-200" style="display: none;">
                    </div>
                    <!-- Tab Content -->
                    <div id="scripture-content" class="mt-4 break-words whitespace-pre-wrap" style="display: none;">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Debug Log Section - Fixed Height -->
    <div class="flex-none bg-white rounded-lg shadow-sm p-4 mt-4">
        <header class="text-lg font-semibold text-gray-800 mb-4">Debug Log</header>
        <section id="message-log"
                 class="h-[200px] font-mono text-sm bg-black text-green-500 rounded-lg p-4 overflow-y-auto">
        </section>
    </div>
</div>
{% endblock %} 